高效App架构设计与重构

## 1.重构

### 1.1重新规划Android项目结构

> - 建立AndroidLib类库，将与业务无关的逻辑转移到AndroidLib。
>
> - 多个包例如：
>
>   > - activity
>   > - adapter：适配器
>   > - entity：实体类
>   > - db：SQLLite相关逻辑封装
>   > - engine：业务相关类
>   > - ui：自定义控件
>   > - utils公用方法
>   > - interfaces：接口
>   > - listener
>
> - 两个目的：
>
>   > - 每个文件只有一个单独的类，不要嵌套。
>   > - Activity按模块拆分归类后，可以迅速定位具体的一个界面。

### 1.2为Activity定义新的生命周期

> - 可以在AndroidLib类库BaseActivity中，重写onCreat方法：
> - 子方法要声明为abstract
>
> ```java
> public abstract class  BaseActivity extends Activity {
>    @Override
>    protected void onCreate(@Nullable Bundle savedInstanceState) {
>        super.onCreate(savedInstanceState);
> 
>        initVariables();
>        initViews(savedInstanceState);
>        loadData();
>    }
>    protected abstract void initVariables();
>    protected abstract void initViews( Bundle savedInstanceState);
>    protected abstract void loadData();
> }
> ```
>
> - Activity继承BaseActivity
>
> ```java
> public class LoginActivity extends BaseActivity implements View.OnClickListener {
>     
>     @Override
>     protected void onCreate(@Nullable Bundle savedInstanceState) {
>         super.onCreate(savedInstanceState);
>     }
> 
>    @Override
>    protected void initVariables() {
>        //初始化变量，包含Intent带的数据和Activity内的变量
>    }
> 
>    @Override
>    protected void initViews(Bundle savedInstanceState) {
>        setContentView(R.layout.activity_login);
>        //加载layout布局，初始化控件，为控件挂上事件
>    }
> 
>    @Override
>    protected void loadData() {
>        //获取数据。eg.API
>    }
> 
>    @Override
>    public void onClick(View v) {
> 
>    }
> }
> ```
>

### 1.3统一事件编程模板

> - 按钮点击事件
> - 解决swith...case...臃肿问题
>
> ```java
> //登录事件
>         btnLogin = (Button)findViewById(R.id.sign_in_button);
>         btnLogin.setOnClickListener(
>                 new View.OnClickListener(){
>                     @Override
>                     public void onClick(View v) {
>                         gotoLoginActivity();
>                     }
>                 }
>         );
> ```
>
> - 将onClick实现封装在gotoLoginActivity方法中
>
> ```java
> private void gotoLoginActivity(){
>     Intent intent=new Intent(LoginNewActivity.this,PersonCenterActivity.class);
>     startActivity(intent);
> }
> ```

### 1.4实体化编程

> - 引入fastJSON和GSON的包
>
> ```java
> //fastJSON
> WeatherEntity weatherEntity=JSON.parseObject(content,WeatherEntity.class);
> WeatherInfo weatherInfo=weatherEntity.getWeatherInfo();
> if(weatherInfo!=null){
> tvCity.setText(weatherInfo.getCity());
> tvCityId.setText(weatherInfo.getCityid());
> }
> //JSON
> Gson gson=new Gson();
> WeatherEntity weatherEntity=gson.fromJson(content,WeatherEntity.class);
> WeatherInfo weatherInfo=weatherEntity.getWeatherInfo();
> if(weatherInfo!=null){
> tvCity.setText(weatherInfo.getCity());
> tvCityId.setText(weatherInfo.getCityid());
> }
> ```
>
> 
>
> - 避免加了符号的Annotation实体属性和泛型属性使用崩溃。混淆文件加入：
>
> ```
> -keepattributes Signature     //避免混淆泛型
> -keepattributes *Annotation*  //不混淆注解
> ```
>
> - 实体生成器
>
>   > - https://www.xamasoft.com/json-class-generator/
>
> - 在页面跳转中使用实体
>
>   > - 不推荐全局变量，App在后台内存可能会被回收。**使用全局变量要序列化到本地**。
>   > ```java
>   > //源
>   > Intent intent=new Intent(MainActivity.this,LoginNewActivity.class);
>   > CinemaBean cinema=new Cinema();
>   > cinema.setCinemaId("1");
>   > cinima.setCinemaName("Jim");
>   > 
>   > //使用intent 上挂可序列化实体的方式传递参数
>   > intent.putExtra(AppConstants.Cinema,cinema);
>   > startActivity(intent);
>   > ```
>   >
>   >  ```java
>   >   //目标
>   >   CinemaBean cinema=(CinemaBean)getIntent().getSbleExtra(AppConstants.Cinema);
>   >   if(cinema!=null){
>   >   	cimemaName=cimema.getCinemaName();
>   >   }else{
>   >   	cimemaName="";
>   >   }
>   >   ```
>   >  ```java
>   >   //CinemaBean要实现Serializable接口，以支持序列化
>   >   public class CinemaBean implements Serializable{
>   >   	private static final long serialVersionUID=1L;
>   >   	private String cinemaId;
>   >   	private String cinemaName;
>   >	//省略get...set...方法
>   > }
>   > ```

### 1.5Adapter 模板

> - Adapter 都继承自 BaseAdapter，从构造函数注入List<自定义实体>数据集合，从而完成ListView填充。
>
> ```java
> public class CinemaAdapter extends baseAdapter{
>    private final ArrayList<CinemaBean> cinemaList;
>    private final AppBaseActivity context;
>    
>    public CinemaAdapter(ArrayList<CinemaBean> cinemaList,AppBaseActivity context){
>        this.cinemaList=cinemaList;
>        this.context=context;
>    }
>    
>    public int getCount(){
>        return cinemaList.size();
>    }
>    
>    public CinemaBean getItem(final int position){
>        return cinemaList.get(position);
>    }
>    
>    public long getItemId(final int position){
>        return position;
>    }
>    //要内置一个Holder嵌套类，用于存放ListView中的每一行的空间。ViewHolder可以避免频繁创建同一个列表项，节省内存。
>    class Holder{
>        TextView tvCinemaName;
>        TextView tvCinemaId;
>    }
>    
>    public View getView(final int position,View convertView,final viewGroupparent){
>        final Holder holder;
>        if(convertView==null){
>            holder=new Holder();
>            convertView=context.getLayoutInflater().inflate(R.layout.item_cinemalist,null);
>            holder.tvCinemaName=(TextView)convertView.findViewById(R.id.tvCinemaName);
>            holder.tvCinemaId=(TextView)convertView.findViewById(R.id.tvCinemaId);
>            convertView.setTag(holder);
>        }else{
>            holder=(Holder)convertview.getTag();
>        }
>        CinemaBean cinema=cinemaList.get(position);
>        holder.tvCimemaName.setText(cinema.getCinemaName());
>        holder.tvCimemaId.setText(cinema.getCinemaId());
>        return convertView;
>    }
> }
> ```
> - 使用
>
> ```java
> @Override
> protected void initViews(bundle savedInstanceState){
>     setContentView(R.layout.activity_listdemo);
>     lvCinemaList=(ListView)findViewById(R,id,lvCinemalist);
>     
>     CinemaAdapter adapter=new CinemaAdapter(cimemaList,ListDemoActivity.this);
>     lvCinemaList.setAdapter(adapter);
>     lvCinemaList.setOnItemClickListener(){
>         @Override
>         public void onItemClick(AdapterView<?> parent,View view,int position,long id){
>             //do something
>         }
>     }
>     
> }
> ```

### 1.6类型安全转换函数

>- 类型转换不正确导致崩溃的问题主要集中在**Object类型的对象**和**substring函数**。
>
>- 当Object类型的对象对其调用toString( )操作时，当其为null是，崩溃。
>
>- part1：错误例子：
>
>```java
>//obj为null时崩溃,obj一般是从JSON数据中取出来的。
>int result=Integer.valueOf(obj.toString());
>```
>
>- part1：正确例子：安全转换函数convertToInt
>
>```java
>public final static int convertToInt（Object value,int defaultValue）{
>    if(value==null || "".equals(value.toString().trim())){
>        return defaultValue;
>    }
>    try{
>        return Integer.valueOf(value.toString());
>    }catch(Exception e){
>        try{
>            return Double.valueOf(value.toString()).intValue();
>        }catch (Exception e1){
>            return defaultValue;
>        }
>    }
>}
>```
>
>```java
>//推荐上述方法放到Utils类下面
>int result=Utils.convertToInt(obj,0);
>```
>
>- part2：错误例子
>
>```java
>//substring函数接受两个参数：start和end
>//下述情况崩溃
>String cityName="T";
>String firstLetter=cityName.substring(1,2);
>```
>
>- part2：正确例子
>
>```java
>String cityName="T";
>String firstLetter="";
>if(cityName.length()>1){
>    firstLetter=cityName.substring(1,2);
>}
>```



##  2.Android网络底层框架设计

### 2.1网络底层封装

>- **AsyncTask** 封装网络底层可**扩展性低**。
>
>- 规范JSON数据格式：
>
>```json
>//eg.1
>{
>	"isError":true,
>"errorType":1,
>"errorMessage":"网络异常",
>"result":""
>}
>//eg.2
>{
>	"isError":false,
>"errorType":0,
>"errorMessage":"",
>"result":{
>"cinemaID":1,
>"cinemaName":"Jim"
>}
>}
>```
>
>- 可以定义一个Response实体类，作为所有JSON实体的最外层
>
>```java
>public class Response{
>	private boolean error;
>private int errorType;
>private String errorMessage;
>private String result;
>
>public boolean hasError(){
>return error;
>}
>public void setError(boolean hasError){
>this.error=hasError;
>}
>public String getErrorMessage(){
>return errorMessage;
>}
>public void setErrorMessage(String errorMessage){
>this.errorMessage=errorMessage;
>}
>public String getResult(){
>return result;
>}
>public void setResult(String result){
>this.result=result;
>}
>public int getErrorType(){
>return errorType;
>}
>public void setErrorType(int errorType){
>this.errorType=errorType;
>}
>}
>```
>
>- AsyncTask缺点分析：
>
>> - 线程池中存放MobileAPI的调用请求，而AsyncTask中未暴露取消请求的CancelRequest方法。即A页面跳转B页面，那么在A页面发起的MobileAPI请求如果没有返回，并不会取消。
>
>- 使用原生ThreadPoolExecutor+Runnable+Handler
>
>![1564017552130](C:\Users\Abfahrt\Documents\MdNotes\images\轻量级的网络底层框架.png)
>
>- 简述：
>
>> - **UrlConfigManager和URLData**
>> - 所要调用的所有API接口信息写在url.xml文件中
>>
>> ```xml
>> <?xml version="1.0" encodeing="utf-8">
>> <url>
>> 	<Node 
>> 		Key="getWeatherInfo"
>> 		Expires="300"
>> 		NetType="get"
>> 		Url="http://www.........." />
>> 	<Node 
>> 		Key="login"
>> 		Expires="0"
>> 		NetType="post"
>> 		Url="http://www.........." />
>> </url>
>> ```
>>
>> - 通过UrlConfigManager的findURL方法，在上述xml中找到当前的API调用节点，每个API接口对应一个URLData实体。
>>
>> ```java
>> public class URLData{
>> 	private String key;
>> 	private long expires;	//做缓存用的
>> 	private String netType;
>> 	private String url;
>> }
>> ```
>>
>> - **RemoteService和RequestCallback和RequestParameter**
>>
>> ```java
>> //WeatherByFastJsonActivity中调用实例
>> @Override
>> protected void loadData(){
>>  //RequestCallback回调
>>  weatherCallback=new RequestCallback(){
>>      @Override
>>      WeatherInfo weatherInfo=JSON.parseObject(content,WeatherInfo.class);
>>      if(weatherInfo!=null){
>>          tvCity.setText(weatherInfo.getCity());
>>          tvCityId.setText(weatherInfo.getCituid());
>>      }
>>  }
>>  @Override
>>  public void onFail(String errorMessage){
>>      new AlertDialog.Builder(WeatherByFastJsonActivity.this).setTitle("出错了").setMessage(errorMessage).setPositiveButton("确认",null).show();
>>  }
>> };
>> //RequestParameter传递所需参数键值对，HashMap查找速度o(1),但消耗内存，在数据少时优势不明显。
>> ArrayList<RequestParameter> params=new ArrayList<RequestParameter>();
>> RequestParameter rp1=new RequestParameter("cityId","111");
>> RequestParameter rp2=new RequestParameter("cityName","Beijing");
>> parama.add(rp1);
>> parama.add(rp2);
>> 
>> RemoteService.getInstance().invoke(this,"getWeatherInfo",params,weatherCallback);
>> ```
>>
>> - **RequestManager**
>> - 用于取消请求
>>
>> ```java
>> public void cancelRequest(){
>>  if((requestList!=null)&&(requestList.size()>0)){
>>      for(fianl HttpRequest request:requestList){
>>          if(request.getRequest()!=null){
>>              try{
>>                  request.getRequest().abort();
>>                  requestList.remove(request.getRequest());
>>              }catch(final UnsupportedOperationException e){
>>                  e.printStackTrace();
>>              }
>>          }
>>      }
>>  }
>> }
>> ```
>>
>> - 在BaseActivity保持对RequestManager的引用，在onDestory( )和onPause( )时执行cancelRequest( )
>>
>> ```java
>> public abstract class BaseActivity extends Activity{
>>  //请求列表管理器
>>  protected RequestManager requestManager=null;
>>  
>>  protected void onDestory(){
>>      if(requestManager!=null){
>>          requestManager.cancelRequest();
>>      }
>>      super.onDestory();
>>  }
>>  
>>  protected void onPause(){
>>      if(requestManager!=null){
>>          requestManager.cancelRequest();
>>      }
>>      super.onPause();
>>  }
>>  
>>  public RequestManager getRequestManager(){
>>      return requestManager;
>>  }
>> }
>> ```
>>
>> - **DefaultThreadPool**
>>
>> - 是对ThreadPoolExecutor和ArrayBlockingQueue的封装，就是一个线程池，每发起一次请求（runnable），就由线程池分配一个新的线程来执行该请求。
>>
>> - **HttpRequest**
>>
>> - HttpRequest 是发起Http 请求的地方，它实现了Runnable，从而让DefaultThreadPool 可
>> 以分配新的线程来执行它，所有的请求逻辑都在Runnable 接口的run 方法中。
>>
>>   > - 对于get形式的MobileAPI接口，它会把从上层传递进来的ArrayList<RequestParameter>，解析为url?k1=v1&k2=v2 这样的形式。
>>   > - 对于post格式的MobileAPI接口，它会把从上层传递进来的ArrayList<RequestParameter>，转为BasicNameValuePair 的形式，放到表单中进行提交
>>
>> - 每个HttpRequest 都放在了新的子线程上执行，所以回
>> 调RequestCallback 的onSuccess 方法时， 不能直接操作UI 线程上的控件， 所以我们在
>> HttpRequest 类中使用了Handler。
>>
>> ```java
>> if (responseInJson.hasError()) {
>> 	handleNetworkError(responseInJson.getErrorMessage());
>> 	} else {
>> 		handler.post(new Runnable() {
>> 		@Override
>> 		public void run() {
>> 		HttpRequest.this.requestCallback.onSuccess(responseInJson.getResult());
>> 		}
>> 	});
>> }
>> ```
>>
>> - Activity中
>>
>>   ```java
>>   weatherCallback = new RequestCallback() {
>>   	@Override
>>   	public void onSuccess(String content) {
>>   		WeatherInfo weatherInfo = JSON.parseObject(content,WeatherInfo.class);
>>   		if (weatherInfo != null) {
>>   		tvCity.setText(weatherInfo.getCity());
>>   		tvCityId.setText(weatherInfo.getCityid());
>>   		}
>>   }
>>   ```
>
>- 优化
>
>> - **onFail 的统一处理机制**
>> - 不希望每次都编写同样的onFail 方法，这会使程序很臃肿。于是在AppBaseActivity中写一个自定义类AbstractRequestCallback
>>
>> ```java
>> public abstract class AppBaseActivity extends BaseActivity {
>> 	public abstract class AbstractRequestCallback implements RequestCallback {
>> 		public abstract void onSuccess(String content);
>> 		public void onFail(String errorMessage) {
>> 			new AlertDialog.Builder(AppBaseActivity.this).setTitle(" 出错了").setMessage(errorMessage).setPositiveButton(" 确定", null).show();
>> 	   	}
>> 	   }
>> }
>> ```
>>
>> - weatherRequestCallback 的实例化
>>
>> ```java
>> weatherCallback = new AbstractRequestCallback() {
>> 	@Override
>> 	public void onSuccess(String content) {
>> 		WeatherInfo weatherInfo = JSON.parseObject(content,WeatherInfo.class);
>> 		if (weatherInfo != null) {
>> 			tvCity.setText(weatherInfo.getCity());
>> 			tvCityId.setText(weatherInfo.getCityid());
>> 		}
>> 	}
>> };
>> ```
>>
>> - 在返回错误时需要App 特殊处理，比如重启App 或者什么都不做，我们只需要在实例化AbstractRequestCallback 时，重写onFail 方法即可。
>> ---
>> - **UrlConf igManager 的优化**
>>
>> - 在一个大量调用MobileAPI 的App 中，这样的设计会造成频繁读xml 文件，性能很
>> 差。改造：App 启动时，一次性将url.xml 文件都读取到内存，把所有的UrlData 实体保存在一个集合中，然后每次调用MobileAPI 接口，直接从内存的这个集合中查找。考虑到内存中的数据会被回收，所以上述这个集合一旦为空，我们要从url.xml中再次读取。
>>
>> ```java
>> public static URLData findURL(final Activity activity,final String findKey) {
>> 	// 如果urlList 还没有数据（第一次）
>> 	// 或者被回收了，那么（重新）加载xml
>> 	if (urlList == null || urlList.isEmpty())
>> 		fetchUrlDataFromXml(activity);
>> 	for (URLData data : urlList) {
>> 		if (f indKey.equals(data.getKey())) {
>> 			return data;
>> 		}
>> 	}
>> 	return null;
>> }
>> ```
>> ---
>> - **不是每个请求都需要回调的**
>>
>> ```java
>> /*将空的RequestCallback传给HttpRequest
>> *在HttpRequest处理请求返回的结果时，就需要添加HttpRequest是否为空的判断
>> *不空，才会处理返回结果
>> *否则，发起API请求后什么都不做
>> */
>> void loadAPIData3() {
>> 	ArrayList<RequestParameter> params= new ArrayList<RequestParameter>();
>> 	RequestParameter rp1 =new RequestParameter("cityId", "111");
>> 	RequestParameter rp2 =new RequestParameter("cityName", "Beijing");
>> 	params.add(rp1);
>>    params.add(rp2);
>> 	RemoteService.getInstance().invoke(this, "getWeatherInfo", params, null);
>> }
>> ```
>>
>> ```java
>> //需要修改的地方
>> //1）处理请求时：
>> response = httpClient.execute(request);
>> if ((requestCallback != null)) {
>> 	// 获取状态
>> 	final int statusCode =response.getStatusLine().getStatusCode();
>> 	if (statusCode == HttpStatus.SC_OK) {
>>        final ByteArrayOutputStream content =new ByteArrayOutputStream();
>> 
>> //2）遇到异常，是否要回调onFail 方法：
>> public void handleNetworkError(final String errorMsg) {
>> 	if ((requestCallback != null)) {
>> 		handler.post(new Runnable() {
>> 			@Override
>> 			public void run() {
>> 				HttpRequest.this.requestCallback.onFail(errorMsg);
>> 			}
>> 		});
>> 	}
>> }
>> ```
>> ---
>> - **ProgressBar 的处理**
>>
>> - App 要保持风格统一，所以所有页面的ProgressBar 应该长得一样.
>>
>>   ```java
>>   //其定义在AppBaseActivity 中
>>   public abstract class AppBaseActivity extends BaseActivity {
>>   	protected ProgressDialog dlg;
>>   	public abstract class AbstractRequestCallback implements RequestCallback {
>>           public abstract void onSuccess(String content);
>>   		public void onFail(String errorMessage) {
>>   			dlg.dismiss();
>>   			new AlertDialog.Builder(AppBaseActivity.this).setTitle(" 出错啦").setMessage(errorMessage).setPositiveButton(" 确定", null).show();
>>   		}
>>   	}
>>   }
>>   ```
>>
>>   ```java
>>   //在开始调用MobileAPI 的地方，执行show 方法；在onSuccess 和onFail方法的开始，执行dismiss 方法：
>>   @Override
>>   protected void loadData() {
>>   	dlg = Utils.createProgressDialog(this,this.getString(R.string.str_loading));
>>   	dlg.show();
>>   	loadAPIData1();
>>   }
>>   void loadAPIData1() {
>>   	weatherCallback = new AbstractRequestCallback() {
>>   	@Override
>>   	public void onSuccess(String content) {
>>   	dlg.dismiss();
>>   	WeatherInfo weatherInfo = JSON.parseObject(content,WeatherInfo.class);
>>   	if (weatherInfo != null) {
>>   ```
>> - 不要把Dialog 的show 方法和dismiss 方法封装到网络底层。网络底层的调用经常是在
子线程执行的，子线程是不能操作Dialog、Toast 和控件的。

### 2.2App数据缓存设计

>- App 缓存只能针对于MobileAPI 中**GET** 类型的接口，对于POST 不适用。
>
>- 对于那些即时性很低的缓存，对于那些即时性比较高、频繁变动的数据不能进行缓存。
>
>- 缓存数据比较大，其存在SD 卡上，而不是内存中。
>
>- 注意：
>
>  > - 可以将xxx.api?k1=va&k2=v2 这样的URL 格式作为key，存放App 缓存数据。
>  > - 需要注意的是，要对k1、k2 这些key 进行排序，这样才能唯一
>  > - 对于如下URL：
>  >   xxxx.api?k1=v1&k2=v2
>  >   xxxx.api?k2=v2&k1=v1
>  > - 会被认为是两个不同的key 存放在缓存中。实际上是一样的。
>
>- 对于App 而言，它是感受不到取的是缓存数据还是调用MobileAPI。**具体工作由网络底层完成**。
>
>- 在url.xml 中为每一个MobileAPI 接口配置缓存时间Expired。post不需要缓存，一律设置为0。
>
>- HttpRequest 类中的run 方法中，改动3 个地方:
>
>  > - 写一个排序算法sortKeys，对URL 中的key 进行排序。
>  >
>  > - 将newUrl 作为key，检查缓存中是否有数据，有则直接返回；否则，继续调用MobileAPI 接口。
>  >
>  >   ```java
>  >   // 如果这个get 的API 有缓存时间（大于0）
>  >   if (urlData.getExpires() > 0) {
>  >   	final String content = CacheManager.getInstance().getFileCache(newUrl);
>  >   	if (content != null) {
>  >   		handler.post(new Runnable() {
>  >   		@Override
>  >   		public void run() {
>  >   			requestCallback.onSuccess(content);
>  >   			}
>  >   		});
>  >   	return;
>  >   	}
>  >   }
>  >   ```
>  >
>  > - API 接口返回数据后，将数据存入缓存。
>  >
>  >   ```java
>  >   final Response responseInJson = JSON.parseObject(strResponse,Response.class);
>  >   	if (responseInJson.hasError()) {
>  >   		handleNetworkError(responseInJson.getErrorMessage());
>  >   	} else {
>  >   		// 把成功获取到的数据记录到缓存
>  >   		if (urlData.getNetType().equals(REQUEST_GET)&&urlData.getExpires() > 0) {
>  >               		CacheManager.getInstance().putFileCache(newUrl,responseInJson.getResult(),urlData.getExpires());
>  >   		}
>  >   		handler.post(new Runnable() {
>  >   		@Override
>  >   		public void run() {
>  >   			requestCallback.onSuccess(responseInJson.getResult());
>  >   		}
>  >   	});
>  >   }
>  >   ```
>  >
>  > - CacheManager 用于操作读写缓存数据，并判断缓存数据是否过期。缓存中存放的实体就是CacheItem。
>  >
>  > - 在App 项目中，创建Application 级别的类，在程序启动时，初始化缓存的目录，如果不存在则创建之。
>  >
>  >   ```java
>  >   public class ExampleApplication extends Application {
>  >   	@Override
>  >   	public void onCreate() {
>  >   		super.onCreate();
>  >           CacheManager.getInstance().initCacheDir();
>  >   	}
>  >   }
>  >   ```
>  >
>  > - 在AndroidManifest.xml 文件中，指定application 的android:name 为Example-
>  >   Application：
>  >
>  >   ```xml
>  >   <application
>  >   	android:allowBackup="true"
>  >   	android:name="com.example.exampleApplication"
>  >   ```
>  >
>  > - 对缓存数据，有特殊需求的App，可以将要缓存的数据转成byte 数组再序列化到本地，要用的时候再反过来操作。
>
>- 强制更新
>
>  > - 以让RemoteService 多暴露一个boolean 类型的参数，用于判断是否要遵守App
>  >   端缓存策略，如果是，则在从url.xml 中取出UrlData 实体后，将其expired 强制设置为0，就不会执行缓存策略。
>  >
>  >   ```java
>  >   public void invoke(final BaseActivity activity,
>  >   				final String apiKey,
>  >   				final List<RequestParameter> params,
>  >   				final RequestCallback callBack) {
>  >   	invoke(activity, apiKey, params, callBack, false);
>  >   }
>  >   
>  >   public void invoke(final BaseActivity activity,
>  >   				final String apiKey,
>  >   				final List<RequestParameter> params,
>  >   				final RequestCallback callBack,
>  >   				final boolean forceUpdate) {
>  >   	final URLData urlData =UrlConfigManager.findURL(activity, apiKey);
>  >   	if(forceUpdate) {
>  >   	// 如果强制更新，那么就把过期时间强制设置为0
>  >   		urlData.setExpires(0);
>  >   	}
>  >   	HttpRequest request =activity.getRequestManager().createRequest(urlData, params, callBack);
>  >   	DefaultThreadPool.getInstance().execute(request);
>  >   }
>  >   ```
>  >
>  > - 调用的时候，只需要加一个参数。
>  >
>  > - 可以提供一个强制刷新的按钮，点击按钮后，页面会重新调用API 加载数据，无论缓存是否到期。
>

### 2.3MockService

>- API 接口还没好，而App 又急等着用的情况。
>
>- 设计App 端MockService 包括如下几个关键点：
>
>>- 对需要Mock 数据的MobileAPI 接口，通过在url.xml 中配置Node 节点MockClass属性，来指定要使用那个Mock 子类生成的数据：
>
> > ```xml
> > <Node
> > 	Key="getWeatherInfo"
> > 	Expires="300"
> > 	NetType="get"
> > MockClass="com.youngheart.mockdata.MockWeatherInfo"
> > Url="http://www.weather.com.cn/data/sk/101010100.html" />
> > ```
> > ```
> > 
> > - 使用反射工厂来设计MockService。MockService 类是基类，它有一个抽象方法
> > getJsonData，用于返回手动生成的Mock 数据。
> > 
> > ​```java
> > public abstract class MockService {
> > 	public abstract String getJsonData();
> > }
> > ```
> >
> > - 每个要Mock 数据的MobileAPI 接口，都对应一个继承自MockService 的子类，都要实现各自的getJsonData 方法，返回不同的JSON 数据。
> >
> > ```java
> > public class MockWeatherInfo extends MockService {
> > 	@Override
> > 	public String getJsonData() {
> > 		WeatherInfo weather = new WeatherInfo();
> > 		weather.setCity("Beijing");
> > 		weather.setCityid("10000");
> > 		Response response = getSuccessResponse();
> > 		response.setResult(JSON.toJSONString(weather));
> > 		return JSON.toJSONString(response);
> > 	}
> > }
> > ```
> >
> > - 实现反射机制
> >
> > - 改造工作在RemoteService 类的invoke 方法中，根据是否在url.xml 中指定了MockClass 值来决定，是调用线上MobileAPI 还是从本地MockService 直接取假数据。
> >
> >   ```java
> >   //如果MockClass 有值，就把这个值反射为一个具体的类，比如MockWeatherInfo，然后调用它的getJsonData 方法
> >   public void invoke(final BaseActivity activity,final List<RequestParameter> params,final RequestCallback callBack) {
> >   	final URLData urlData = UrlConfigManager.findURL(activity, apiKey);
> >   	if (urlData.getMockClass() != null) {
> >   		try {
> >   			MockService mockService = (MockService)Class.forName(urlData.getMockClass()).newInstance();
> >   			String strResponse = mockService.getJsonData();
> >   			final Response responseInJson =JSON.parseObject(strResponse,Response.class);
> >   			if (callBack != null) {
> >   				if (responseInJson.hasError()) {
> >   					callBack.onFail(responseInJson.getErrorMessage());
> >   				} else {
> >   					callBack.onSuccess(responseInJson.getResult());
> >   				}
> >   			}
> >   		} catch (ClassNotFoundException e) {
> >   			e.printStackTrace();
> >   		} catch (InstantiationException e) {
> >   			e.printStackTrace();
> >   		} catch (IllegalAccessException e) {
> >   			e.printStackTrace();
> >   		}
> >   	} else {
> >   		HttpRequest request =activity.getRequestManager().createRequest(urlData, params, callBack);
> >   		DefaultThreadPool.getInstance().execute(request);
> >   	}
> >   }
> >   ```
> >

### 2.4用户登录

>- 贯穿App 的，应该有一个User 全局变量，在每次登录成功后，会将其isLogin 属性设置为true，在退出登录后，则将该属性设置为false。
>
>- 三种情形：
>
>> - 点击登录按钮，进入登录页面LoginActivity，登录成功后，直接进入个人中心PersonCenterActivity。
>>
>> - 在页面A，想要跳转到页面B，并携带一些参数，却发现没有登录，于是先跳转到登录页，登录成功后，再跳转到B 页面，同时仍然带着那些参数。
>>
>> ```java
>> //主要是setResult(intent, resultCode)作用的，Activity 回调机制。
>> btnLogin2.setOnClickListener(new OnClickListener(){
>> 	@Override
>> 	public void onClick(View v) {
>> 		if(User.getInstance().isLogin()) {
>> 			gotoNewsActivity();
>> 		} else {
>> 			Intent intent = new Intent(LoginMainActivity.this,LoginActivity.class);
>> 			intent.putExtra(AppConstants.NeedCallback, true);
>> 			startActivityForResult(intent,LOGIN_REDIRECT_OUTSIDE);
>> 		}
>> 	}
>> });
>> ```
>>
>> - 在页面A，执行某个操作，却发现没有登录，于是跳转到登录页，登录成功后，再回到页面A，继续执行该操作。
>>
>> ```java
>> btnLogin3.setOnClickListener(new OnClickListener(){
>> 	@Override
>> 	public void onClick(View v) {
>> 		if(User.getInstance().isLogin()) {
>> 		changeText();
>> 	} else {
>> 		Intent intent = new Intent(LoginMainActivity.this,LoginActivity.class);
>> 		intent.putExtra(AppConstants.NeedCallback, true);
>> 		startActivityForResult(intent,LOGIN_REDIRECT_INSIDE);
>> 		}
>> 	}
>> });
>> ```
>>
>> - 整合三个逻辑
>>
>> ```java
>> RequestCallback loginCallback = new AbstractRequestCallback() {
>> 	@Override
>> 	public void onSuccess(String content) {
>> 	UserInfo userInfo = JSON.parseObject(content,UserInfo.class);
>> 		if (userInfo != null) {
>> 		User.getInstance().reset();
>> 		User.getInstance().setLoginName(userInfo.getLoginName());
>> 		User.getInstance().setScore(userInfo.getScore());
>> 		User.getInstance().setUserName(userInfo.getUserName());
>> 		User.getInstance().setLoginStatus(true);
>> 		User.getInstance().save();
>> 	}
>> 	if(needCallback) {
>> 		setResult(Activity.RESULT_OK);
>> 		finish();
>> 	} else {
>> 		Intent intent = new Intent(LoginActivity.this,PersonCenterActivity.class);
>> 		startActivity(intent);
>> 		}
>> 	}
>> };
>> ```
>> - 最后在LoginMainActivity 中的onActivityResult 回调函数，处理登录后的事情。
>>
>> ```java
>> @Override
>> protected void onActivityResult(int requestCode,int resultCode, Intent data){
>> 	if (resultCode != Activity.RESULT_OK) {
>> 		return;
>> 	}
>> 	switch (requestCode) {
>> 		case LOGIN_REDIRECT_OUTSIDE:
>> 			gotoNewsActivity();
>> 			break;
>> 		case LOGIN_REDIRECT_INSIDE:
>> 			changeText();
>> 			break;
>> 		default:
>> 		break;
>> 	}
>> }
>> ```
>
>- 自动登录
>
>> - 本地保存密码：使用不对称加密才安全。
>>
>> - 登录后，用户调用API接口时应把UserId和加密后(哈希散列算法不对称加密)的密码一起传递。
>>
>> - 本地保存密码自动登录问题：
>>
>>   > - 本地保存密码自动登录时，登录界面一闪而过。
>>   > - 本地保存密码自动登录时，验证码环节。
>>
>> - 使用Cookie机制完成自动登录。
>>
>>   > - App 登录成功后，会从服务器获取到一个Cookie，这个Cookie 存放在Http-
>>   > Response 的header 中。
>>   >
>>   > - ```html
>>   >   Set-Cookie: customer=huangxp; path=/foo; domain=.ibm.com;
>>   >   expires= Wednesday, 19-OCT-05 23:12:40 GMT; [secure]
>>   >   ```
>>   > ```
>>   > 
>>   > ```
>>   >
>>   > ```
>>   > - 我们将Cookie存放在本地文件中即可。
>>   > 
>>   > - 修改App 的网络底层，也就是HttpRequest 类.
>>   > 
>>   > ​```java
>>   > /*
>>   > *每次发起MobileAPI请求时，都要把本地保存的Cookie取出来
>>   > *放到HttpRequest的header中。
>>   > */
>>   > // 添加Cookie 到请求头中
>>   > addCookie();
>>   > // 发送请求
>>   > response = httpClient.execute(request);
>>   > ```
>>   >
>>   > ```java
>>   > /*每次接收API的相应结果时，都把HttpResponse的header里面的Cookie取出来
>>   > *覆盖本地保存的Cookie
>>   > */
>>   > if (urlData.getNetType().equals(REQUEST_GET)&& urlData.getExpires() > 0) {
>>   > 	CacheManager.getInstance().putFileCache(newUrl,responseInJson.getResult(),urlData.getExpires());
>>   > 	}
>>   >
>>   > handler.post(new Runnable() {
>>   > 	@Override
>>   > 	public void run() {
>>   > 		requestCallback.onSuccess(responseInJson.getResult());
>>   > 	}
>>   > });
>>   > // 保存Cookie
>>   > saveCookie();
>>   > ```
>>   > 
>>   > ​```java
>>   > //addCookie和saveCookie方法的实现
>>   > public void addCookie() {
>>   > 	List<SerializableCookie> cookieList = null;
>>   > 	Object cookieObj = BaseUtils.restoreObject(cookiePath);
>>   > 	if (cookieObj != null) {
>>   > 		cookieList = (ArrayList<SerializableCookie>) cookieObj;
>>   > 	}
>>   > 	if ((cookieList != null) && (cookieList.size() > 0)) {
>>   > 		final BasicCookieStore cs = new BasicCookieStore();
>>   > 		cs.addCookies(cookieList.toArray(new Cookie[] {}));
>>   > 		httpClient.setCookieStore(cs);
>>   > 	} else {
>>   > 		httpClient.setCookieStore(null);
>>   > 	}
>>   > }
>>   > 
>>   > public synchronized void saveCookie() {
>>   > 	// 获取本次访问的cookie
>>   > 	final List<Cookie> cookies =httpClient.getCookieStore().getCookies();
>>   > 	// 将普通cookie 转换为可序列化的cookie
>>   > 	List<SerializableCookie> serializableCookies = null;
>>   > 	if ((cookies != null) && (cookies.size() > 0)) {
>>   > 		serializableCookies = new ArrayList<SerializableCookie>();
>>   > 		for (final Cookie c : cookies) {
>>   > 		serializableCookies.add(new SerializableCookie(c));
>>   > 		}
>>   > 	}
>>   > 	BaseUtils.saveObject(cookiePath, serializableCookies);
>>   > }
>>   > ```
>>
>> - 如果是用户信息相关的，则判断HttpRequest 中Cookie 是否有效；如果是用户无关的，则不需要检查HttpRequest 中Cookie。
>>
>> - 用户注销功能，要把本地保存的 Cookie 清空。App 判断用户是否登录的标志，就是Cookie 是否为空。
>>
>> - 用户注册功能，一般在注册成功后，都会拿着用户名和密码再调用一次登录接口，解决方案是：1.注册成功后直接跳转到登录页面，让用户手动再输入一次。2.另一种解决方案是，注册成功后进入个人中心页面，不需要再登录一次，而是把注册和登录接口绑在一起。
>>
>> - Cookie 过期，App 应该跳转到登录页面，让用户手动进行登录。**挑战**：登录成功后，应该返回手动登录之前的那个页面。
>
>- Cookie 过期的统一处理
>
>> - Cookie 不是一直有效的，到了一定时间就会失效。
>>
>>   ```json
>>   {
>>   "isError" : true,
>>   "errorType" : 1,
>>   "errorMessage" : "Cookie 失效，请重新登录",
>>   "result" : ""
>>   }
>>   ```
>>
>> - 修改AndroidLib，支持Cookie 失效的场景
>>
>>   ```java
>>   //RequestCallback中增加一种onCookieExpired回调方法
>>   public interface RequestCallback
>>   {
>>   	public void onSuccess(String content);
>>   	public void onFail(String errorMessage);
>>   	public void onCookieExpired();
>>   }
>>   //在网络底层对JSON返回结果进行解析，如果发现是属于Cookie过期的错误类型，就直接回调onCookieExpired方法
>>   final Response responseInJson=JSON.parseObject(strResponse,Response.class);
>>   if(responseInJson.hasError()){
>>   	if(responseInJson.getErrorType() == 1){
>>   	handler.post(new Runnable() {
>>   		@Override
>>   		public void run() {
>>   		requestCallback.onCookieExpired();
>>   		}
>>   	});
>>   	}else{
>>   	handleNetworkError(responseInJson.getErrorMessage());
>>   }
>>   ```
>>
>>   ```java
>>   //对网络底层进行了高度的封装，增加一种新的回调很简单
>>   public void onCookieExpired() {
>>   	dlg.dismiss();
>>   	new AlertDialog.Builder(AppBaseActivity.this)
>>   		.setTitle(" 出错啦")
>>   		.setMessage("Cookie 过期，请重新登录")
>>   		.setPositiveButton(" 确定",new DialogInterface.OnClickListener() {
>>   	@Override
>>   		public void onClick(DialogInterface dialog,int which) {
>>   			Intent intent = new Intent(AppBaseActivity.this,LoginActivity.class);
>>   		intent.putExtra(AppConstants.NeedCallback,true);
>>   		startActivity(intent);
>>   		}
>>   	}).show();
>>   }
>>   ```
>
>- 防止刷库
>
>> - 安全解决方案是为登录接口增加第三个参数---验证码。
>>
>> - 连续登录3 次失败后，才要求用户输入验证码情况下：
>>
>>   > - API 在发现有同一 IP 短时间内频繁访问某一个API 接口时，就直接返回一段HTML5，要求用户输入验证码。
>>   > - App 在接收到这段代码时，就在页面上显示一个浮层，里面一个 WebView，显示这个要求用户输入验证码的HTML5。



### 2.5HTTP头中的奥妙

> - GET / POST
>
>   > - GET
>   >
>   >   ```java
>   >   if(urlData.getNetType().equals(REQUEST_GET)) {
>   >   	// 添加参数
>   >   	final StringBuffer paramBuffer = new StringBuffer();
>   >   	if ((parameter != null) && (parameter.size() > 0)) {
>   >   		// 这里要对key 进行排序
>   >   		sortKeys();
>   >   		for(final RequestParameter p : parameter) {
>   >               if (paramBuffer.length() == 0) {
>   >                   paramBuffer.append(p.getName() + "=" + BaseUtils.UrlEncodeUnicode(p.getValue()));
>   >               } else {
>   >                   paramBuffer.append("&" + p.getName() + "=" + BaseUtils.UrlEncodeUnicode(p.getValue()));
>   >               }
>   >           }
>   >           newUrl = url + "?" + paramBuffer.toString();
>   >       } else {
>   >           newUrl = url;
>   >       }
>   >       request = new HttpGet(newUrl);
>   >   }
>   >   ```
>   >
>   > - POST
>   >
>   >   ```java
>   >   else if (urlData.getNetType().equals(REQUEST_POST)) {
>   >       request = new HttpPost(url);
>   >   	// 添加参数
>   >   	if ((parameter != null) && (parameter.size() > 0)) {
>   >           final List<BasicNameValuePair> list =new ArrayList<BasicNameValuePair>();
>   >           for (final RequestParameter p : parameter) {
>   >               list.add(new BasicNameValuePair(p.getName(), p.getValue()));
>   >           }
>   >           ((HttpPost) request).setEntity(new UrlEncodedFormEntity(list, HTTP.UTF_8));
>   >       }
>   >   }
>   >   ```
>
> - HTTP Header
>
>   > - App 开发人员而言，只要按照API 的要求，把这些key 所需要的值拼接成HTTPRequest 头正确传递。
>   >
>   >   ```java
>   >   void setHttpHeaders(final HttpUriRequest httpMessage){
>   >   	headers.clear();
>   >   	headers.put(FrameConstants.ACCEPT_CHARSET, "UTF-8,*");
>   >   	headers.put(FrameConstants.USER_AGENT,"Android App");
>   >   	if ((httpMessage != null) && (headers != null)){
>   >           for (final Entry<String, String> entry : headers.entrySet())
>   >           {
>   >               if (entry.getKey()!=null){
>   >                   httpMessage.addHeader(entry.getKey(), entry.getValue());
>   >               }
>   >           }
>   >       }
>   >   }
>   >   ```
>   >
>   >   ```java
>   >   //Cookie之前调用setHttpHeaders
>   >   // 添加必要的头信息
>   >   setHttpHeaders(request);
>   >   // 添加Cookie 到请求头中
>   >   addCookie();
>   >   // 发送请求
>   >   response = httpClient.execute(request);
>   >   ```
>
> - 时间校准
>
>   > ```java
>   > void updateDeltaBetweenServerAndClientTime() {
>   >     if (response != null) {
>   >         final Header header = response.getLastHeader("Date");
>   >         if (header != null) {
>   >             final String strServerDate = header.getValue();
>   >             try {
>   >                 if ((strServerDate != null) && !strServerDate.equals("")) {
>   >                     final SimpleDateFormat sdf = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss z", Locale.ENGLISH);
>   >                     TimeZone.setDefault(TimeZone.getTimeZone("GMT+8"));
>   >                     Date serverDateUAT = sdf.parse(strServerDate);
>   >                     deltaBetweenServerAndClientTime = serverDateUAT.getTime() + 8 * 60 * 60 * 1000 - System.currentTimeMillis();
>   >                 }
>   >             } catch (java.text.ParseException e) {
>   >                 e.printStackTrace();
>   >             }
>   >         }
>   >     }
>   > }
>   > ```
>   >
>   > ```java
>   > //发起API 网络请求得到响应结果后，执行该方法，更新这个差值：
>   > // 发送请求
>   > response = httpClient.execute(request);
>   > // 获取状态
>   > final int statusCode = response.getStatusLine().getStatusCode();
>   > // 设置回调函数，但如果requestCallback，说明不需要回调，不需要知道返回结果
>   > if ((requestCallback != null)) {
>   >     if (statusCode == HttpStatus.SC_OK) {
>   > 	// 更新服务器时间和本地时间的差值
>   > 	updateDeltaBetweenServerAndClientTime();
>   > ```
>   >
>   > - 把deltaBetweenServerAndClientTime 方法暴露出来，供外界调用
>   >
>   > ```java
>   > public static Date getServerTime() {
>   > 	return new Date(System.currentTimeMillis() + deltaBetweenServerAndClientTime);
>   > }
>   > ```
>   >
>   > - 示范
>   >
>   > ```java
>   > btnShowTime.setOnClickListener(new View.OnClickListener() {
>   > 	@Override
>   > 	public void onClick(View v) {
>   > 		String strCurrentTime = Utils.getServerTime().toString();
>   > 		new AlertDialog.Builder(WeatherByFastJsonActivity.this)
>   > 			.setTitle(" 当前时间是：").setMessage(strCurrentTime)
>   > 			.setPositiveButton(" 确定", null).show();
>   > 	}
>   > });
>   > ```
>
> - 开启gzip 压缩
>
>   > - 1.减少存储空间；2.通过网络传输时，减少传输的时间
>   >
>   > - 使用gzip 的流程：
>   >
>   >   > - App 发起请求时，在HTTPRequest 头中，添加要求支持gzip 的key-value，key 是Accept-Encoding，value 是gzip。
>   >   >
>   >   >   ```java
>   >   >   //需要修改setHttpHeaders方法
>   >   >   void setHttpHeaders(f inal HttpUriRequest httpMessage) {
>   >   >   	headers.clear();
>   >   >   	headers.put(FrameConstants.ACCEPT_CHARSET, "UTF-8,*");
>   >   >   	headers.put(FrameConstants.USER_AGENT, "Android App ");
>   >   >   	headers.put(FrameConstants.ACCEPT_ENCODING, "gzip");
>   >   >   	if ((httpMessage != null) && (headers != null)) {
>   >   >   		for (final Entry<String, String> entry : headers.entrySet()) {
>   >   >               if (entry.getKey() != null) {
>   >   >                   httpMessage.addHeader(entry.getKey(),entry.getValue());
>   >   >               }
>   >   >           }
>   >   >       }
>   >   >   }
>   >   >   ```
>   >   >
>   >   > - API 的逻辑是，检查HTTP 请求头中的Accept-Encoding 是否有gzip 值，如果有，就会执行gzip 压缩。如果执行了gzip 压缩，那么在返回值也就是HTTPResponse 的头中，有一个contentencoding字段，会带有gzip 的值；否则，就没有这个值。
>   >   >
>   >   > - App 检查HTTPResponse 头中的content-encoding 字段是否包含gzip 值，这个值的有
>   >   >   无，会导致了App 解析HTTPResponse 的方式不同。
>   >   >
>   >   >   ```java
>   >   >   	String strResponse = "";
>   >   >   	if ((response.getEntity().getContentEncoding() != null)&& (response.getEntity().getContentEncoding().getValue() != null)) {
>   >   >           if (response.getEntity().getContentEncoding().getValue().contains("gzip")) {
>   >   >               final InputStream in = response.getEntity().getContent();
>   >   >               final InputStream is = new GZIPInputStream(in);
>   >   >               strResponse = HttpRequest.inputStreamToString(is);
>   >   >               is.close();
>   >   >           } else {
>   >   >               response.getEntity().writeTo(content);
>   >   >               strResponse = new String(content.toByteArray()).trim();
>   >   >           }
>   >   >       } else {
>   >   >           response.getEntity().writeTo(content);
>   >   >           strResponse = new String(content.toByteArray()).trim();
>   >   >       }
>   >   >   ```



## 3.经典场景设计

### 3.1App图片缓存技术

> - JavaEE 与 Android 开发：OOM - Out of Memory，内存溢出。
>
> - **ImageLoader 目的**：实现异步的网络图片加载、缓存及显示，支持多线程异步加载。
>
> - **ImageLoader工作原理**：显示图片的时候，它会先在内存中查找；如果没有，就去本地查找；如果还没有，就开一个新的线程去下载这张图片，下载成功会把图片同时缓存到内存和本地。
>
> - 每次退出一个页面的时候，把ImageLoader 内存中的缓存清除，节省内存，再用到的时候从本地提取。
>
> - 于ImageLoader 对图片是**软引用的形式**，所以内存中的图片会在内存不足的时候被系统回收。
>
> - ImageLoader使用
>
>   > - ImageLoader 三大组件:
>   >
>   >   > - **ImageLoaderConfiguration**——对图片缓存进行总体配置，包括内存缓存的大小、本地缓存的大小和位置、日志、下载策略（FIFO 还是LIFO）等等。
>   >   >
>   >   > - **ImageLoader**——我们一般使用displayImage来把URL对应的图片显示在ImageView上。
>   >   >
>   >   > - **DisplayImageOptions**——在每个页面需要显示图片的地方，控制如何显示的细节，比如指定下载时的默认图（包括下载中、下载失败、URL 为空等），是否将缓存放到内
>   >   >   存或者本地磁盘。
>   >   >
>   >   >   > 参考地址：https://www.cnblogs.com/kissazi2/p/3886563.html
>   >
>   > - 在ExampleApplication 中总体配置ImageLoader：
>   >
>   >   ```java
>   >   public class ExampleApplication  extends Application {
>   >   	@Override
>   >   	public void onCreate() {
>   >   		super.onCreate();
>   >   		CacheManager.getInstance().initCacheDir();
>   >   		ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext())
>   >   			.threadPriority(Thread.NORM_PRIORITY - 2)
>   >   			.memoryCacheExtraOptions(480, 480)
>   >               .memoryCacheSize(2 * 1024 * 1024)
>   >   			.denyCacheImageMultipleSizesInMemory()
>   >   			.discCacheFileNameGenerator(new Md5FileNameGenerator())
>   >   			.tasksProcessingOrder(QueueProcessingType.LIFO)
>   >   			.memoryCache(new WeakMemoryCache()).build();
>   >   		ImageLoader.getInstance().init(config);
>   >       }
>   >   }
>   >   ```
>   >
>   > - 使用ImageView 加载图片的地方，配置当前页面的ImageLoader 选项。可能是Activity，也有可能是Adapter：
>   >
>   >   ```java
>   >   public CinemaAdapter(ArrayList<CinemaBean> cinemaList,AppBaseActivity context) {
>   >       this.cinemaList = cinemaList;
>   >   	this.context = context;
>   >   	options = new DisplayImageOptions.Builder()
>   >   		.showStubImage(R.drawable.ic_launcher)
>   >   		.showImageForEmptyUri(R.drawable.ic_launcher)
>   >   		.cacheInMemory()
>   >   		.cacheOnDisc()
>   >   		.build();
>   >   }
>   >   ```
>   >
>   > - 在使用ImageView 加载图片的地方，使用ImageLoader：
>   >
>   >   ```java
>   >   CinemaBean cinema = cinemaList.get(position);
>   >   holder.tvCinemaName.setText(cinema.getCinemaName());
>   >   holder.tvCinemaId.setText(cinema.getCinemaId());
>   >   context.imageLoader.displayImage(cinemaList.get(position).getCinemaPhotoUrl(), holder.imgPhoto);
>   >   ```
>
> - ImageLoader 优化
>
>   > - AppBaseActivity 中的onDestroy 方法中，执行ImageLoader 的clearMemoryCache方法，以确保页面销毁时，把为了显示这个页面而增加的内存缓存清除。
>   >
>   >   ```java
>   >   public abstract class AppBaseActivity extends BaseActivity {
>   >   	protected boolean needCallback;
>   >   	protected ProgressDialog dlg;
>   >   	public ImageLoader imageLoader = ImageLoader.getInstance();
>   >   	protected void onDestroy() {
>   >   		// 回收该页面缓存在内存的图片
>   >   		imageLoader.clearMemoryCache();
>   >   		super.onDestroy();
>   >   	}
>   >   ```
>
> - ImageLoader 资源
>
>   > 1）简介ImageLoader。
>   > 地址：http://blog.csdn.net/yueqinglkong/article/details/27660107
>   > 2）Android-Universal-Image-Loader 图片异步加载类库的使用（超详细配置）
>   > 地址：http://blog.csdn.net/vipzjyno1/article/details/23206387
>   > 3）Android 开源框架Universal-Image-Loader 完全解析。
>   > 地址：http://blog.csdn.net/xiaanming/article/details/39057201
>
> - 图片加载Fresco
>
>   > - 在 Application 级别，对 Fresco 进行初始化：
>   >
>   >   ```java
>   >   Fresco.initialize(getApplicationContext());
>   >   ```
>   >
>   > - Fresco 是基于控件级别的，把程序中显示网络图片的ImageView 都替换为SimpleDraweeView 即可，并在ImageView 所在的布局文件中添加fresco 命名空间。
>   >
>   >   ```xml
>   >   <LinearLayout
>   >   	xmlns:android="http://schemas.android.com/apk/res/android"
>   >   	xmlns:fresco="http://schemas.android.com/apk/res-auto">
>   >   <com.facebook.drawee.view.SimpleDraweeView
>   >   	android:id="@+id/imgView"
>   >   	android:layout_width="10dp"
>   >   	android:layout_height="10dp"
>   >   	fresco:placeholderImage="@drawable/placeholder" />
>   >   ```
>   >
>   > - 在 Activity 中为这个图片控件指定要显示的网络图片：
>   >
>   >   ```java
>   >   Uri uri = Uri.parse("http://www.bb.com/a.png");
>   >   draweeView.setImageURI(uri);
>   >   ```
>
> - Fresco 的原理是，Image Pipeline 的概念。它负责先后检查内存、磁盘文件（Disk），如果都没有再从网络下载图片。
>
>   ![9](C:\Users\Abfahrt\Documents\MdNotes\images\ImagePipeline的工作流.png)
>
> - 上图中：箭头上标记了jpg 或bmp格式的，表示Cache 中有图片，直接取出；没有标记，则表示Cache 中找不到。
>
> - **Fresco 三层缓存的概念**：(它比其他图片SDK吃内存小)
>
>   > - 第一层：**Bitmap 缓存**
>   >
>   >   > - 在 Android 5.0 系统中，Bitmap 缓存位于 Java 的堆（heap）中。
>   >   > - 在 Android 4.x 和更低的系统，Bitmap 缓存位于 ashmem 中，而不是位于 Java 的堆
>   >   >   （heap）中。
>   >   >
>   >   > 当App 切换到后台时，Bitmap 缓存会被清空。
>   >
>   > - 第二层：**内存缓存**
>   >
>   >   > - 内存缓存中存储了图片的原始压缩格式。从内存缓存中取出的图片，在显示前必须先解
>   >   >   码。当App 切换到后台时，内存缓存也会被清空。
>   >
>   > - 第三层：**磁盘缓存**
>   >
>   >   > - 磁盘缓存，又名本地存储。磁盘缓存中存储的也是图片的原始压缩格式。在使用前也要
>   >   >   先解码。
>
> - Fresco参考资料：
>
>   > - Fresco 在 GitHub 上的源码：https://github.com/mkottman/AndroLua
>   > - Fresco 官方文档：http://fresco-cn.org/docs/index.html



### 3.2对网络流量的优化

> - **通信层面的优化**
>
>   > - API 接口返回的数据，要使用**gzip** 进行压缩。注意：大于1KB 才进行压缩。经过gzip 压缩后，返回的数据量大幅减少。
>   >
>   > - App 与MobileAPI 之间的数据传递，通常是遵守JSON 协议的。JSON 因为是xml 格式的，并且是以字符存在的，在数据量上还有可以压缩的空间。使用**ProtoBuffer**，这种二进制格式的协议，在表示大数据时，空间比JSON 小很多。
>   >
>   > - 减少网络访问次数，能调用一次API 接口就能取到数据的，就不要调用两次。
>   >
>   > - 传统的API 使用的是HTTP 无状态短连接。使用HTTP 协议的速度远不如使用长连接的TCP 协议。所以**使用TCP 长连接**，可提高访问的速度。缺点：一台服务器能支持的长连接个数不多，需要更多的服务器集成。
>   >
>   > - **建立取消网络请求的机制**。一个页面如果没有请求完网络数据，在跳转到另一个页面之前，要把之前的网络请求都取消，不再等待，也不再接收数据。
>   >
>   > - **增加重试机制**。如果API 是严格的RESTful 风格，一般将获取数据的请求接口都定义为get；而把操作数据的请求接口都定义为post。
>   >
>   >   > - 可以为所有的get 请求配置重试机制，比如get 请求失败后重试3 次。
>   >   >
>   >   > - post 请求是不建议有重试机制的。
>   >   >
>   >   > - 所有的post 请求，都要增加防止用户1 分钟内频繁发起相同请求的机制，这样就能有效防止重复下单、重复发表评论、重复注册等操作。
>   >   > - 如果post 请求具有防重机制，那么倒是可以增加重试机制。但是要可以在服务器端灵活配置重试的次数，可以是0 次，意味着不会重试。
>   >   > - 在App 启动的时候，告诉App 所有的MobileAPI 接口的重试次数。
>
> - **图片策略优化**
>
>   > - **确保下载的每张图，都符合ImageView 控件的大小**。
>   >
>   > - 每次根据URL 请求图片时，要额外在URL 上加上两个参数，width 和height，从而要求服务器返回其中某一张图，URL 如下所示：http://www.aaa.com/a.png?width=100&height=50。
>   >
>   > - 准备一台服务器，称为ImageServer。（这种方案只需要一张图）
>   >
>   >   > - App 每次加载图片，都会把URL 地址以及width 和height 参数所组成的字符串进行encode，然后发送给ImageServer，新的URL 如下所示：http://www.ImageServer.com/getImage?param=(encodevalue)
>   >   >
>   >   > - ImageServer 收到这个请求，会把param 的值decode，得到原始图片的URL，以及App 想要显示的这张图片的width 和height。ImageServer 会根据URL 获取到这张原始图片，然后根据width 和height，重新进行绘制，保存到ImageServer 上，并返回给App。
>   >   >
>   >   > - 最后，App 请求到的是一张符合其显示大小的图片。
>   >   >
>   >   > - 要每天清一次硬盘，不然过不了几天硬盘就满。
>   >   >
>   >   > - 如果width 和height 的比例与原图的宽高比不一致呢？我们需要再加一个参数imagetype。
>   >   >
>   >   >   > - 1 表示等比缩放后，裁减掉多余的宽或者高
>   >   >   > - 2 表示等比缩放后，不足的宽或者高填充白色。
>   >
>   > - ImageServer 频繁地写硬盘，硬盘坚持不了多久。
>   >
>   > - 在出口加以控制：向ImageServer 发起请求的时候。拿实际的图片尺寸，去轮询事先规定好几个尺寸看更接近哪个。找最接近图片尺寸的办法是面积法：
>   >
>   >   ```java
>   >   S = (w1-w) × (w1-w) + (h1-h) × (h1-h)
>   >   //w和h是实际的图片宽和高，w1和h1是事先规定的某个尺寸的宽和高。S最小的那个，就是最接近的。
>   >   ```
>   >
>   > - **低流量模式**
>   >
>   > - 在2G 和3G 网络环境下，应该适当降低图片的质量。降低图片质量，相应的图片大小也会降低，称为低流量模式。
>   >
>   > - **极速模式**
>   >
>   > - 额外设计一些页面，区别于正常模式下图文并茂的页面，将这些只有文字的页面称为极速模式。



### 3.3城市列表的设计

> - 一份城市列表的数据包括以下几个字典:
>
>   > - cityId：城市 Id。
>   > - cityName：城市名称。
>   > - pinyin：城市全拼。
>   > - jianpin：城市简拼。
>
> - 写死在本地文件的做法缺点：
>
>   > - Android 和 iOS 维护的数据，差异会越来越大。
>   > - 一千多个城市，每次从本地加载都要很长时间。
>   > - 序列化过的城市列表直接保存到本地速度得到提升，但每次增加新的城市，都要等下次发版，因为数据是写死在App 本地的。
>
> - 把城市列表数据做成一个接口，由API 去后台采集数据，这样数据是最新最准的。
>
>   > - API 接口返回的数据量会很大，上千笔数据，还包括那么多字段，即使打开了gzip 压缩，也会很大。
>   >
>   > - 增加了**版本号字段version 的概念**。
>   >
>   >   > - 入参。version，本地存储的城市列表数据对应的版本号。
>   >   >
>   >   > - 返回值。如果传入参数version 和线上最新版本号一致，则返回以下固定格式：
>   >   >
>   >   >   ```json
>   >   >   {
>   >   >   "isMatch": true,
>   >   >   "version": 1,
>   >   >   "cities": [
>   >   >       	{
>   >   >       	},
>   >   >   	]
>   >   >   }
>   >   >   ```
>   >   >
>   >   > - 如果传入参数version 和线上最新版本号不一致，则返回以下格式:
>   >   >
>   >   >   ```json
>   >   >   {
>   >   >   	"isMatch": false,
>   >   >   	"version": 1,
>   >   >   	"cities": [
>   >   >   		{
>   >   >   			"cityId": 1,
>   >   >   			"cityName": " 北京",
>   >   >   			"pinyin": "beijing",
>   >   >   			"jianpin": "bj"
>   >   >   		},
>   >   >   		{
>   >   >   			"cityId": 2,
>   >   >   			"cityName": " 上海",
>   >   >   			"pinyin": "shanghai",
>   >   >   			"jianpin": "sh"
>   >   >   		},
>   >   >   		{
>   >   >   			"cityId": 3,
>   >   >   			"cityName": " 平顶山",
>   >   >   			"pinyin": "pingdingshan",
>   >   >   			"jianpin": "pds"
>   >   >   		}
>   >   >   	]
>   >   >   }
>   >   >   ```
>   >
>   > - App 的策略可以是：
>   >
>   >   > - 本地仍然保存一份线上最新的城市列表数据（序列化后的）以及对应的版本号。每次发版前做一次城市数据同步的事情。
>   >   > - 每次进入到城市列表这个页面时，将本地城市列表数据对应的版本号version 传入到API 接口，根据返回的isMatch 值来决定是否版本号一致。如果一致，则直接从本地文件中加载城市列表数据；否则，就解析API 接口返回的数据，在显示列表的同时，要把最新的城市列表数据和版本号保存到本地。
>   >   > - API 接口没有调用成功，也是直接从本地文件中加载城市列表数据，以确保主流程是畅通的。
>   >   > - 每次调用API 时，会获取到大量的数据，一般会打开gzip 对数据进行压缩，以确保传输的数据量最小。
>
> - 城市列表数据的增量更新机制
>
>   > - 增量更新的数据，就由增、删、改这3 部分数据构成。
>   >
>   > - 重新定义城市列表的JSON 格式，在每笔增量数据中增加一个字段type，用来区别是增（c）、删（d）、改（u）中的一种情况。
>   >
>   >   ```json
>   >   {
>   >   	"isMatch": false,
>   >   	"version": 1,
>   >   	"cities": [
>   >   		{
>   >   		"cityId": 1,
>   >   		"cityName": " 北京",
>   >   		"pinyin": "beijing",
>   >   		"jianpin": "bj",
>   >   		"type": "d"
>   >   		},
>   >   		{
>   >   		"cityId": 2,
>   >   		"cityName": " 上海",
>   >   		"pinyin": "shanghai",
>   >   		"jianpin": "sh",
>   >   		"type": "c"
>   >   		},
>   >   		{
>   >   		"cityId": 3,
>   >   		"cityName": " 平顶山",
>   >   		"pinyin": "pingdingshan",
>   >   		"jianpin": "pds",
>   >   		"type": "u"
>   >   		}
>   >   	]
>   >   }
>   >   ```



### 3.4App与HTML5的交互

> - App 操作HTML5 页面的方法
>
>   > - eg.改变HTML5 页面的背景颜色
>   >
>   > - HTML5
>   >
>   >   ```html
>   >   <script type="text/javascript">
>   >   function changeColor (color) {
>   >       document.body.style.backgroundColor = color;
>   >   }
>   >   </script>
>   >   ```
>   >
>   > - Android
>   >
>   >   ```java
>   >   wvAds.getSettings().setJavaScriptEnabled(true);
>   >   wvAds.loadUrl("file:// /android_asset/104.html");
>   >   btnShowAlert.setOnClickListener(new View.OnClickListener() {
>   >   	@Override
>   >   	public void onClick(View v) {
>   >   	String color = "#00ee00";
>   >   	wvAds.loadUrl("javascript: changeColor ('" + color + "');");
>   >   	}
>   >   });
>   >   ```
>
> - HTML5 页面操作App 页面的方法
>
>   > - HTML5
>   >
>   >   ```html
>   >   <a onclick="baobao.callAndroidMethod(100,100,'ccc',true)">
>   >   CallAndroidMethod</a>
>   >   ```
>   >
>   > - Android
>   >
>   >   ```java
>   >   //新创建一个JSInterfacel类，包括callAndroidMethod 方法的实现：
>   >   class JSIntefacel {
>   >   	public void callAndroidMethod(int a, float b,String c, boolean d) {
>   >   		if (d) {
>   >               String strMessage = "-" + (a + 1) + "-" + (b + 1) + "-" + c + "-" + d;
>   >               new AlertDialog.Builder(MainActivity.this).setTitle("title").setMessage(strMessage).show();
>   >           }
>   >       }
>   >   }
>   >   ```
>   >
>   > - 注册baobao 和JSInterfacel的对应关系
>   >
>   >   ```java
>   >   wvAds.addJavascriptInterface(new JSInteface1(), "baobao");
>   >   //注意：部分系统，要在方法前增加@JavascriptInterface，否则，就不能触发JavaScript方法。
>   >   ```
>
> - App 和HTML5 之间定义跳转协议
>
>   > - 在App 中搞活动的解决方案：不必等到App 每次发新版才能看到新的活动页面，而是每次做一个HTML5 的活动页面，然后通过API把这个HTML5 页面的地址告诉App，由App 加载这个HTML5 页面即可。
>
> - 在App 中内置HTML5 页面
>
>   > - assets 目录创建数据模板。
>   >
>   > - MovieDetailActivity 中，通过遍历movieList 这个集合，把数据填充到sbContent中，最终，把拼接好的字符串替换\<data1DefinedByBaobao\> 标签
>   >
>   >   ```java
>   >   String template = getFromAssets("data1_template.html");
>   >   StringBuilder sbContent = new StringBuilder();
>   >   ArrayList<MovieInfo> movieList = organizeMovieList();
>   >   for (MovieInfo movie : movieList) {
>   >   	String rowData;
>   >   	rowData = template.replace("<name>", movie.getName());
>   >   	rowData = rowData.replace("<price>", movie.getPrice());
>   >   	sbContent.append(rowData);
>   >   }
>   >   String realData = getFromAssets("102.html");
>   >   realData = realData.replace("<data1DefinedByBaobao>",sbContent.toString());
>   >   wvAds.loadData(realData, "text/html", "utf-8");
>   >   ```
>
> - 灵活切换Native 和HTML5 页面的策略
>
>   > - Native 页面每次修改，都要等一次迭代上线后才能看到——周期太长。
>   >
>   > - HTML5 的缺点是慢。
>   >
>   > - 可以做两套页面，Native 一套，HTML5一套，在App 中设置一个变量，来判断该页面将显示Native 还是HTML5 的。变量可以从API 获取。
>   >
>   > - App设计思路
>   >
>   >   > - 需要做一个后台，根据版本进行配置每个页面是使用Native 页面还是HTML5 页面。
>   >   > - 在App 启动的时候，从API 获取到每个页面是Native 还是HTML5。
>   >   > - 在App 的代码层面， 页面之间要实现松耦合。为此， 设计一个导航器Navigator，由它来控制该跳转到Native 页面还是HTML5 页面。
>   >   > - 最大的挑战是页面间参数传递，字典是一种比较好的形式，消除了不同页面对参数类型的不同要求。
>
> - 页面分发器
>
>   > - 跳转到一个Activity，需要传递一些参数。这些参数的类型简单如int 和String，复杂的则是列表数据或者可序列化的自定义实体。
>   >
>   > - 从HTML5 页面跳转到Native 页面，不大可能传递复杂类型的实体的，只能传递简单类型。所以，并不是每个Native 页面都可以替换为HTML5。
>   >
>   > - 对于来自HTML5 页面、传递简单类型的页面跳转请求，我其抽象为一个分发器，放到BaseActivity 中。
>   >
>   >   ```html
>   >   <a onclick="baobao.gotoAnyWhere('gotoMovieDetail:movieId=12')">gotoAnyWhere
>   >   </a>
>   >   
>   >   <!--我们将其改写为：-->
>   >   <a onclick="baobao.gotoAnyWhere('com.example.MovieDetailActivity,
>   >   iOS.MovieDetailViewController:movieId=(int)123')">gotoAnyWhere
>   >   </a>
>   >   <!--协议的内容分成3段，第一段是Android 要跳转到的Activity 的名称。第二段是iOS 要跳转到的ViewController的名称，第三段是需要传递的参数，以key-value 的形式进行组装。-->
>   >   ```
>   >
>   > - 从协议URL 中取出第1 段，将其反射为一个Activity 对象，取出第3 段，将其解析为key-value 的形式，然后从当前页面跳转到目标页面并配以正确的参数。
>   >
>   > - 写一个辅助函数getAndroidPageName，用来获取Activity 名称。
>   >
>   >   ```java
>   >   public class BaseActivity extends Activity {
>   >   	private String getAndroidPageName(String key) {
>   >   		String pageName = null;
>   >   		int pos = key.indexOf(",");
>   >   		if (pos == -1) {
>   >   			pageName = key;
>   >   		} else {
>   >   			pageName = key.substring(0, pos);
>   >   		}
>   >           return pageName;
>   >       }
>   >       
>   >   	public void gotoAnyWhere(String url) {
>   >   		if (url == null)
>   >   			return;
>   >   		String pageName = getAndroidPageName(url);
>   >   		if (pageName == null || pageName.trim() == "")
>   >   			return;
>   >   		Intent intent = new Intent();
>   >       	int pos = url.indexOf(":");
>   >   		if (pos > 0) {
>   >   			String strParams = url.substring(pos);
>   >   			String[] pairs = strParams.split("&");
>   >   			for (String strKeyAndValue : pairs) {
>   >   				String[] arr = strKeyAndValue.split("=");
>   >   				String key = arr[0];
>   >   				String value = arr[1];
>   >   				if (value.startsWith("(int)")) {
>   >   					intent.putExtra(key,Integer.valueOf(value.substring(5)));
>   >                   } else if (value.startsWith("(Double)")) {
>   >                       intent.putExtra(key,Double.valueOf(value.substring(8)));
>   >                   } else {
>   >                       intent.putExtra(key, value);
>   >                   }
>   >               }
>   >           }
>   >           try {
>   >               intent.setClass(this, Class.forName(pageName));
>   >           } catch (ClassNotFoundException e) {
>   >               e.printStackTrace();
>   >           }
>   >           startActivity(intent);
>   >       }
>   >   }
>   >   ```
>   >
>   > - 在协议中定义这些简单数据类型的时候，String 是不需要指定类型的，这是使用最广泛的类型。对于int、Double 等简单类型，我们要在值前面加上类似(int) 这样的约定，这样才能在解析时不出问题。



### 3.5消灭全局变量

> - 配置低的手机，重现场景(App 切换到后台，闲置了一段时间后再使用)会崩溃。
>
> - **原因**：在内存不足的时候，系统会回收一部分闲置的资源。
>
> - **把数据作为Intent 的参数传递**：
>
>   > - 目标Activity 被系统销毁了，Intent 上的数据仍存在。（Intent 保存数据比本地文件好）
>   > - Intent 能传递的数据类型必须支持序列化（JSONObject 数据类型无法传递），Intent 上携带数据量过大，也会崩溃。
>
> - **把全局变量序列化到本地**
>
>   > - 仍使用全局变量，在每次修改全局变量的值的时把值序列化到本地文件中，再次使用全局变量时，就从本地文件中反序列化到内存中。
>   >
>   > - 对全局GlobalsVariables 变量进行改造：
>   >
>   > ```java
>   > public class GlobalVariables implements Serializable, Cloneable {
>   > 	/**
>   >   	* @Fields: serialVersionUID
>   > 	*/
>   > 	private static final long serialVersionUID = 1L;
>   > 	private static GlobalVariables instance;
>   > 	private GlobalVariables() {
>   >  
>   > }
>   > public static GlobalVariables getInstance() {
>   >  if (instance == null) {
>   >      Object object = Utils.restoreObject(AppConstants.CACHEDIR + TAG);
>   >      if(object == null) { // App 首次启动，文件不存在则新建之
>   >          object = new GlobalVariables();
>   >          Utils.saveObject(AppConstants.CACHEDIR + TAG, object);
>   >      }
>   >      instance = (GlobalVariables)object;
>   >  }
>   >  return instance;
>   > }
>   > public final static String TAG = "GlobalVariables";
>   > private UserBean user;
>   > public UserBean getUser() {
>   >  return user;
>   > }
>   > public void setUser(UserBean user) {
>   >  this.user = user;
>   >  Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   > }
>   > // — — — — —以下3 个方法用于序列化— — — — — — — —
>   > public GlobalVariables readResolve() throws ObjectStreamException,CloneNotSupportedException {
>   >  instance = (GlobalVariables) this.clone();
>   >  return instance;
>   > }
>   > private void readObject(ObjectInputStream ois) throws IOException,ClassNotFoundException {
>   >  ois.defaultReadObject();
>   > }
>   > public Object Clone() throws CloneNotSupportedException {
>   >  return super.clone();
>   > }
>   > public void reset() {
>   >  user = null;
>   >  Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   > }
>   > }
>   > ```
>   >
>   > - 读写user 数据：
>   >
>   > ```java
>   > UserBean user = GlobalsVariables.getInstance().getUser();
>   > GlobalsVariables.getInstance().setUser(user);
>   > ```
>   >
>   > - GlobalsVariables 必须实现Serializable 接口，以支持序列化自身到本地。然而，为了**使一个单例类变成可序列化**的，仅仅在声明中添加“implements Serializable”是不够的。因为一个序列化的对象在每次反序列化的时候，都会创建一个新的对象，而不仅仅是一个对原有对象的引用。为了防止这种情况，需要在单例类中加入**readResolve** 方法和**readObject**方法，并**实现Cloneable 接口**。
>   >
>   > - **逻辑**：
>   >
>   >   > - 判断instance 是否为空，不为空，证明全局变量没有被回收，可以继续使用；为空，要么是第一次启动App，本地文件都不存在，更不要说序列化到本地了；要么是全局变量被回收了，需要从本地文件中将其还原回来。
>   >   >
>   >   > - 在Utils 类中编写了**restoreObject** 和**saveObject** 两个方法，分别用于把全局变量序列化到本地和从本地文件反序列化到内存。
>   >   >
>   >   > ```java
>   >   > public static final void saveObject(String path, Object saveObject) {
>   >   >     FileOutputStream fos = null;
>   >   > 	ObjectOutputStream oos = null;
>   >   > 	File f = new File(path);
>   >   >     try {
>   >   >         fos = new FileOutputStream(f);
>   >   > 		oos = new ObjectOutputStream(fos);
>   >   > 		oos.writeObject(saveObject);
>   >   >     } catch (FileNotFoundException e) {
>   >   >         e.printStackTrace();
>   >   >     } catch (IOException e) {
>   >   >         e.printStackTrace();
>   >   >     } finally {
>   >   >         try {
>   >   >             if (oos != null) {
>   >   >                 oos.close();
>   >   >             }
>   >   >             if (fos != null) {
>   >   >                 fos.close();
>   >   >             }
>   >   >         } catch (IOException e) {
>   >   >             e.printStackTrace();
>   >   >         }
>   >   >     }
>   >   > }
>   >   > 
>   >   > public static final Object restoreObject(String path) {
>   >   >     FileInputStream fis = null;
>   >   >     ObjectInputStream ois = null;
>   >   >     Object object = null;
>   >   >     File f = new File(path);
>   >   >     if (!f.exists()) {
>   >   >         return null;
>   >   >     }
>   >   > 
>   >   >     try {
>   >   >         fis = new FileInputStream(f);
>   >   >         ois = new ObjectInputStream(f is);
>   >   >         object = ois.readObject();
>   >   >         return object;
>   >   >     } catch (FileNotFoundException e) {
>   >   >         e.printStackTrace();
>   >   >     } catch (IOException e) {
>   >   >         e.printStackTrace();
>   >   >     } catch (ClassNotFoundException e) {
>   >   >         e.printStackTrace();
>   >   >     } finally {
>   >   >         try {
>   >   >             if (ois != null) {
>   >   >     ois.close();
>   >   >             }
>   >   >             if (f is != null) {
>   >   >                 fis.close();
>   >   >             }
>   >   >         } catch (IOException e) {
>   >   >             e.printStackTrace();
>   >   >         }
>   >   >     }
>   >   >     return object;
>   >   > }
>   >   > ```
>   >   >
>   >   > - setUser方法，会在每次设置一个新值后，执行一次Utils 类的saveObject 方法，把新数据序列化到本地。
>   >   >
>   >   > - 如果全局变量中有一个自定义实体的属性，要将这个自定义实体声明为可序列化的，自身也必须实现Serializable 接口。
>   >   >
>   >   > - 全局变量使用范例：
>   >   >
>   >   > ```java
>   >   > //在来源页：
>   >   > private void gotoLoginActivity() {
>   >   > 	UserBean user = new UserBean();
>   >   > 	user.setUserName("Jianqiang");
>   >   > 	user.setCountry("Beijing");
>   >   > 	user.setAge(32);
>   >   > 	Intent intent = new Intent(LoginNew2Activity.this,PersonCenterActivity.class);
>   >   > 	GlobalVariables.getInstance().setUser(user);
>   >   > 	startActivity(intent);
>   >   > }
>   >   > //在目标页PersonCenterActivity：
>   >   > protected void initVariables() {
>   >   > UserBean user = GlobalVariables.getInstance().getUser();
>   >   > 	int age = user.getAge();
>   >   > }
>   >   > ```
>   >   >
>   >   >   - App 启动的时候，要清空存储在本地文件的全局变量。（因为这些全局变量的生命周期都应该伴随着App 的关闭而消亡，来不及在App 关闭的时候做，只好在App 启动的时候第一件事情就是清除这些临时数据）。
>   >   >
>   >   > ```java
>   >   > GlobalVariables.getInstance().reset();
>   >   > ```
>   >   >
>   >   >   - 需在GlobalVariables 这个全局变量类中增加reset 方法，用于清空数据后把空值强制保存到本地。
>   >   >
>   >   > ```java
>   >   > public void reset() {
>   >   > 	user = null;
>   >   > 	Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   > }
>   >   > ```
>   
> - **序列化缺点**：
>
>   > - 每次设置全局变量的值都要强制执行一次序列化的操作，容易造成ANR。(Application Not Responding)
>   >
>   > - 序列化生成的文件，会因为内存不够而丢失。
>   >
>   > - Android 提供的数据类型并不全都支持序列化。
>   >
>   >   ![10](C:\Users\Abfahrt\Documents\MdNotes\images\各种类型数据对序列化的支持程度.png)
>   >
>   > - **JSONObject 和JSONArray序列化解决方案**
>   >
>   >   > - 将其转换为字符串，然后序列化到本地文件。在读取的时，从本地文件反序列化处理这个字符串，然后再把字符串转换为JSONObject 对象。
>   >   >
>   >   >   ```java
>   >   >   private String strCinema;
>   >   >   public JSONObject getCinema() {
>   >   >   	if(strCinema == null)
>   >   >   		return null;
>   >   >   	try {
>   >   >           return new JSONObject(strCinema);
>   >   >       } catch (JSONException e) {
>   >   >           return null;
>   >   >       }
>   >   >   }
>   >   >   public void setCinema(JSONObject cinema) {
>   >   >       if(cinema == null) {
>   >   >           this.strCinema = null;
>   >   >           Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   >           return;
>   >   >       }
>   >   >       this.strCinema = cinema.toString();
>   >   >       Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   >   }
>   >   >   ```
>   >   >
>   >   > - JSONArray只需把上述代码中的JSONObject 替换为JSONArray 即可。
>   >
>   > - **HashMap<String, Object> 和ArrayList<HashMap<String, Object>>序列化解决方案**
>   >
>   >   > - 如果HashMap 中所有的对象都不是JSONObject 和JSONArray，那么以上两种类型就是支持序列化的。
>   >   >
>   >   > - 建议将Object 全都改为String 类型的。
>   >   >
>   >   >   ```java
>   >   >   private HashMap<String, String> rules;
>   >   >   public HashMap<String, String> getRules() {
>   >   >   	return rules;
>   >   >   }
>   >   >   public void setRules(HashMap<String, String> rules) {
>   >   >   	this.rules = rules;
>   >   >   	Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   >   }
>   >   >   ```
>   >   >
>   >   > - 如果HashMap 中存放有JSONObject 或JSONArray，要在set 方法中，遍历HashMap 中存放的每个Object，将其转换为字符串。（繁琐，效率差）
>   >   >
>   >   >   ```java
>   >   >   HashMap<String, Object> guides;
>   >   >   public HashMap<String, Object> getGuides() {
>   >   >   	return guides;
>   >   >   }
>   >   >   public void setGuides(HashMap<String, Object> guides) {
>   >   >   	if (guides == null) {
>   >   >   		this.guides = new HashMap<String, Object>();
>   >   >   		Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   >   		return;
>   >   >   	}
>   >   >   	this.guides = new HashMap<String, Object>();
>   >   >   	Set set = guides.entrySet();
>   >   >   	java.util.Iterator it = guides.entrySet().iterator();
>   >   >   	while (it.hasNext()) {
>   >   >   	java.util.Map.Entry entry = (java.util.Map.Entry) it.next();
>   >   >   	Object value = entry.getValue();
>   >   >   	String key = String.valueOf(entry.getKey());
>   >   >   	this.guides.put(key, String.valueOf(value));
>   >   >   	}
>   >   >   Utils.saveObject(AppConstants.CACHEDIR + TAG, this);
>   >   >   }
>   >   >   ```
>
> - **Activity** 销毁
>
>   > - 内存不足被销毁。
>   >
>   > - 旋转屏幕从竖屏到横屏。
>   >
>   > - Activity 被销毁了，传递到这个Activity 的Intent 并不会丢失，在重新执行Activity的onCreate 方法时，Intent 携带的bundle 参数还是在的。
>   >
>   > - Activity 保存页面状态
>   >
>   >   > - onSaveInstanceState()
>   >   > - onRestoreInstanceState()
>
> - **SharedPreferences**
>
>   > - SharedPreferences中也是可以存取任何支持序列化的数据类型。
>   > - 严格控制SharedPreferences 中存放的变量的数量。
>   > - 页面跳转时要传递的数据放在**Intent** 。
>
> - **User 是唯一例外的全局变量**
>
>   > - 当User 的属性有变动时，要把User 保存。
>   > - 退出登录，把User 类的信息进行清空。
>   > - 与普通全局变量不同，App 启动时不需要清空User 类的数据。




## 4.Android命名规范和代码规范

> - Java类命名：
>
>   > - Activity作为后缀。
>   > - Adapter作为后缀。
>   > - Entity作为后缀。
>
> - 资源文件命名：
>
>   > - 页面布局。act_  前缀。
>   > - ListView。item_  前缀。
>   > - Dialog。dlg_  前缀。
>
> - drawable目录下文件命名。
>
>   > - 只在一个界面使用的资源。该界面名称作为前缀。
>   > - 一个模块下多界面使用的资源。该模块名称作为前缀。
>   > - 每个模块及多个界面使用。比如导航栏，使用common前缀。
>
> - 常用控件缩写
>
> ![1564391604107](C:\Users\Abfahrt\Documents\MdNotes\images\常用控件的缩写.png)
>
> - Layout中常量，要在资源string.xml中定义。
>
> - Activity中常量也要定义在strings.xml中。
>
>   > - String loadingMessage=this.getString(R.string.loadingmessage)；
>
> - Layout中所有控件的字体的大小，都定义在dimens.xml中
>
>   > ```xml
>   > <?xml version="1.0" encoding="utf-8"?>
>   > <resources>
>   > 	<!--字体定义-->
>   > 	<dimen name="font_size_tiny">10sp</demin>
>   > 	<dimen name="font_size_small">12sp</demin>
>   > 
>   > ```
>   >
>   > - 使用方法
>   >
>   > ```xml
>   > <TextView android:textSize="@dimen/fontsize_normal_size" />
>   > ```
>
> - **使用fastJson自定义实体作为API数据载体**。像JSONObject，JSONArray，HashMap<String,Object>,ArrayList<String,Object>不可以序列化，仅用于为实现某算法在方法内部临时使用。
>
> - **页面传值使用Intent携带序列化实体数据的方式**。不要用全局变量传值。
>
> - Activity中不要嵌套内部类。
>
> - Adapter绑定数据，一律为ArrayList<自定义可序列化实体>
>
> - 实体不要在模块间共享，但可以在统一模块不同页面间共享。
>
> - 使用ArrayList<自定义实体>可以**节省内存**，而不是HashMap。尽管ArrayList查找O(n)，HashMap查找O(1)。
>
> - **图片**的处理，统一使用第三方组件ImageLoader或Fresco进行**异步加载**。
>
> - SharedPreference用于存储简单的配置信息，比如设置页面的各种开关。
>
> - 尽量使用**ApplicationContext代替Context**，避免内存泄漏。
>
> - 数据类型转换一定要进行校验。
>
> - 使用常量代替枚举。
>
> - 编码规范扩展内容：
>
>   > - android-formatting.xml
>   > - checkstyle

